package rest

import (
	"net/http"
	"strconv"

	"github.com/anz-bank/go-course/10_rest/nickolee/pkg/puppy"

	"github.com/go-chi/chi"
	"github.com/go-chi/render"
)

const (
	invalidInputMsg = "Invalid input, ensure ID and JSON are valid"
	notFoundMsg     = "Not Found: Apologies, for the puppy you seek does not exist"
)

// PuppyHandlerAndStorer is a special guy who wraps around Storer types and gives them extra abilities
// to now handle API requests thus enhancing their storing abilities significantly!
type PuppyHandlerAndStorer struct {
	Storage puppy.Storer // Using the thread safe sync.map implementation of Storer interface
	// ask Dan what the significance would be if I used storage store.SyncStore vs just store.SyncStore
}

// This guy gives u a nicely initialised brand new *PuppyHandlerAndStorer
func NewPuppyHandlerAndStorer(s puppy.Storer) *PuppyHandlerAndStorer {
	return &PuppyHandlerAndStorer{Storage: s}
}

// Implmenting 1/4 methods in PuppyHandler interface: puppy handler for GET /api/puppy/{id}
func (phs *PuppyHandlerAndStorer) handleGet(w http.ResponseWriter, r *http.Request) {
	// parse incoming request url param
	id, err := strconv.Atoi(chi.URLParam(r, "id")) // strip off the {id} part of the endpoint and convert to int
	if err != nil {
		// if err != nil means user didn't provide proper id hence 404
		http.Error(w, "Bad Request: "+invalidInputMsg, http.StatusBadRequest)
		return
	}
	pup, err := phs.Storage.ReadPuppy(id)
	if err != nil {
		http.Error(w, notFoundMsg, http.StatusNotFound)
		// http.NotFound(w, r)
		return
	}
	render.JSON(w, r, pup) // if retrieved from storage can now send it back out after json serialisation
}

// Implmenting 2/4 methods in PuppyHandler interface: puppy handler for  POST /api/puppy/
func (phs *PuppyHandlerAndStorer) handlePost(w http.ResponseWriter, r *http.Request) {
	var pup puppy.Puppy
	// the following block is saying if I take the incoming body of the request and if I can successfully unmarshal
	// into the Go Puppy object this means the requestor has sent me valid puppy JSON so I can work with that
	if err := render.DecodeJSON(r.Body, &pup); err != nil {
		http.Error(w, "Bad Request: "+invalidInputMsg, http.StatusBadRequest)
		return
	}
	// Actually create a new Puppy in store
	id, err := phs.Storage.CreatePuppy(&pup)
	if err != nil {
		http.Error(w, err.Error(), http.StatusUnprocessableEntity) // if err return a 422
		return
	}
	// else if all is well tell the client the puppy has been successfully created
	render.Status(r, http.StatusCreated)
	pup.ID = id            // tacking on the id generated by the server
	render.JSON(w, r, pup) // confirm this is what has been created on backend
}

// Implmenting 3/4 methods in PuppyHandler interface: puppy handler for  PUT /api/puppy/{id}
func (phs *PuppyHandlerAndStorer) handlePut(w http.ResponseWriter, r *http.Request) {
	// parse incoming request url param
	id, err := strconv.Atoi(chi.URLParam(r, "id")) // strip off the {id} part of the endpoint and convert to int
	if err != nil {
		http.Error(w, "Unprocessable Entity: "+invalidInputMsg, http.StatusBadRequest)
		return
	}

	// check if puppy with given id exists in storage
	_, err = phs.Storage.ReadPuppy(id)
	if err != nil {
		http.Error(w, notFoundMsg, http.StatusNotFound)
		return
	}

	// now deal with the body of the PUT request
	var pup puppy.Puppy
	// decode json and unmarshal into var pup
	if err := render.DecodeJSON(r.Body, &pup); err != nil {
		http.Error(w, "Unprocessable Entity: "+invalidInputMsg, http.StatusUnprocessableEntity)
		return
	}
	// Actually update corresponding Puppy in store
	err = phs.Storage.UpdatePuppy(id, &pup)
	if err != nil {
		http.Error(w, "Unprocessable Entity: "+invalidInputMsg, http.StatusUnprocessableEntity) // if err return a 422
		return
	}
	// else if all is well tell the client the puppy has been successfully updated
	render.Status(r, http.StatusCreated)
	render.JSON(w, r, pup) // confirm this is what has been created on backend
}

// Implmenting 4/4 methods in PuppyHandler interface: puppy handler for DELETE /api/puppy/{id}
func (phs *PuppyHandlerAndStorer) handleDelete(w http.ResponseWriter, r *http.Request) {
	// parse incoming request url param
	id, err := strconv.Atoi(chi.URLParam(r, "id")) // strip off the {id} part of the endpoint and convert to int
	if err != nil {
		// if err != nil means user didn't provide proper id hence 400
		http.Error(w, "Bad Request: "+invalidInputMsg, http.StatusBadRequest)
		return
	}

	// actually perform delete operation
	err = phs.Storage.DeletePuppy(id)
	if err != nil {
		http.Error(w, notFoundMsg, http.StatusNotFound)
		return
	}

	// give client feedback. Opted for this rather than render.Status(r, http.StatusNoContent) as gives more feedback
	render.JSON(w, r, "Puppy successfully deleted")
}

// SetupRoutes maps the exposed endpoints with their respective handlers
func SetupRoutes(r chi.Router, phs PuppyHandlerAndStorer) {
	r.Get("/api/puppy/{id}", phs.handleGet)
	r.Post("/api/puppy/", phs.handlePost)
	r.Put("/api/puppy/{id}", phs.handlePut)
	r.Delete("/api/puppy/{id}", phs.handleDelete)
}
